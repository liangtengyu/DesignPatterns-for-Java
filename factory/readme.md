## 工厂模式学习的思考
### 工厂分类
 
工厂模式可以细分为三种类型：简单工厂、工厂方法和抽象工厂。

当创建逻辑比较复杂时，就可以考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。何为创建逻辑毕竟复杂呢？主要有两种情况，第一种情况是类似规则配置解析的例子，代码中存在 if-else 分支判断，动态的根据不同的类型创建不同的对象。针对这种情况，我们就可以考虑使用工厂模式，将这一大块的 if-else 创建对象的代码抽离出来，放到工厂类中。还有一种情况是，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作，在这种情况下，我们也可以考虑使用工厂模式。

常见的工厂模式有 DataFormat 类、String.valueOf 等等。


### 带着问题学习
搞清楚应用场景：什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？

### 简单工厂（Simple Factory）
首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。

[简单工厂模式](src/main/java/simpleFactory)

```java
public class ColaFactory {

    public static Cola getInstance(Integer  colaType) {
        if (1 == colaType) {
            return new Cocacola();
        } else if (2 == colaType) {
            return new Pepsicola();
        } else {
            return new Fakecola();
        }
    }

}
```

```java
 public static void main(String[] args) {
        String drink = ColaFactory.getInstance(1).drink();
        System.out.println(drink);
    }
    //喝可口可乐
    //喝可口可乐
```
总结一下，尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下是没有问题的。

### 工厂方法（Factory Method）
工厂方法是简单工厂的进一步的延伸，这样说是因为简单工厂违反了开闭原则，而此时工厂方法却可以完美的解决这个问题！接下来看看它是怎么解决的吧！

[工厂方法 - 项目](src/main/java/factoryMethod)


对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。

### 什么时候该用工厂方法模式，而非简单工厂模式呢？
之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们`使用简单工厂模式来实现`，`就只能选择第一种包含 if 分支逻辑的实现方式`。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。


### 抽象工厂（Abstract Factory）
抽象工厂模式的应用场景比较特殊，没有前两种常用，简单了解一下就可以了

[抽象工厂 - 项目](src/main/java/abstractFactory)

